* UNDERWAY org-super-agenda                                       :Emacs:Org:
:PROPERTIES:
:ID:       d816ac2e-3af2-4f1d-bd7e-d8314bdcca1a
:END:
:LOGBOOK:
-  State "UNDERWAY"   from              [2017-07-23 Sun 11:51]
:END:

[2017-07-23 Sun 11:51] I want a more powerful way to build Org agendas.  I want to be able to take a standard Org agenda view and separate items into sections.  This is different from the existing support for sections in the agenda, because that only allows each section to be built from scratch individually.  I just want to take existing items collected for the agenda and display them in separate sections.

I want to be able to pass a list of headers with filter criteria, and any item matching a filter (top-down, first-come-first-serve, or maybe put items in every filter they match) gets shown in that section instead of in the main, unfiltered section.  Something like:

#+BEGIN_SRC elisp
  '(("Bills"
     :tags-any "bills")
    ("Deadline"
     :filter-fns (org-has-deadline-p)
     :sort org-priority-down)
    ("Habits"
     :filter-fns (org-is-habit-p))
    ("Prayers"
     :tags-any "prayers")
    ("Emacs"
     :tags-any ("Emacs" "Org"))
    ("To-Read"
     :todo "TO-READ"))
#+END_SRC

Here's my initial plan.  What I basically need to do is run the standard agenda command, but get the list of items instead of filling the agenda buffer.  Then I can rearrange those items, and then insert into the agenda buffer myself.  This may end up being practically rewriting or at least refactoring the agenda function.  The hardest part may be doing the insertion in the same way the agenda does, preserving the metadata and such.

** Testing code

#+BEGIN_SRC elisp
  (let ((org-agenda-custom-commands (list (quote ("u" "SUPER Agenda"
                                                  org-super-agenda ""
                                                  ((super-filters '((osa/separate-by-any-tags ("bills"))
                                                                    (osa/separate-by-any-tags ("apartment"))
                                                                    osa/separate-by-habits))
                                                   (org-agenda-span 'day)))))))
    (org-agenda nil "u"))
#+END_SRC

** TODO Get list of agenda items from agenda function, just before it inserts into the agenda buffer
:LOGBOOK:
CLOCK: [2017-07-23 Sun 12:24]
:END:

+  =org-agenda-get-day-entries= is the function that "does the work" for the agenda.  If I need to build a custom command sort-of from scratch, this is probably how to start.

#+NAME: get-agenda-item
#+BEGIN_SRC elisp :results silent :cache yes
  (defun osa/get-first-agenda-item () (car (org-agenda-get-day-entries "~/org/main.org" (calendar-current-date) :deadline)))
#+END_SRC

+  =org-agenda-list= is the function that makes the default agenda view.
     -  It seems to use ~(org-agenda-finalize-entries rtnall 'agenda)~ to return a string containing the actual items to insert.  So maybe I can just override that function, although I'm not sure if that's enough, because I don't think that function creates section headers.
** TODO Filter list according to passed arguments

*** DONE Filter by tags
CLOSED: [2017-07-23 Sun 15:36]
:LOGBOOK:
-  State "DONE"       from "TODO"       [2017-07-23 Sun 15:36]
:END:

#+BEGIN_SRC elisp :results list
  (defun osa/get-tags (s)
    "Return list of tags in agenda item string S."
    (org-find-text-property-in-string 'tags s))

  ;; (seq-intersection (osa/get-tags (osa/get-first-agenda-item))
  ;;                   '("bills"))

  (defun osa/separate-by-any-tags (items tags)
    "Separate agenda ITEMS into two lists, putting items that contain any of TAGS into the second list.
  Returns list like (SECTION-NAME NON-MATCHING MATCHING)."
    (let ((section-name (concat "Items tagged with: "
                                (s-join " OR " tags))))
      (cl-loop for item in items
               for item-tags = (osa/get-tags item)
               if (seq-intersection item-tags tags)
               collect item into matching
               else collect item into non-matching
               finally return (list section-name non-matching matching))))

  (-let (((non-matching . matching) (osa/separate-by-any-tags (seq-subseq (org-agenda-get-day-entries "~/org/main.org"
                                                                                                      (calendar-current-date)
                                                                                                      :deadline)
                                                                          0 5)
                                                              '("apartment"))))
    (list (seq-subseq non-matching 0 2)
          (seq-subseq matching 0 1)))
#+END_SRC

[2017-07-23 Sun 13:53] Okay, this is a good prototype: it takes a list of agenda items and separates it into two lists, one containing items that don't match the tags, and one containing items that do.  Note that it may not be sorted; I think that happens at a later step.

*** TODO Filter habits

#+BEGIN_SRC elisp
  (defun osa/separate-by-habits (items &ignore)
    "Separate habits into separate list.
  Returns (\"Habits\" NON-HABITS HABITS)."
    (cl-loop for item in items
             for marker = (org-find-text-property-in-string 'org-marker item)
             if (org-is-habit-p marker)
             collect item into matching
             else collect item into non-matching
             finally return (list "Habits" non-matching matching)))
#+END_SRC

** TODO Insert into agenda buffer

+  =org-agenda-prepare= is an early step.
+  =org-agenda-finalize= may be relevant here.
+  =org-agenda-list= runs ~(setq buffer-read-only t)~ at the very end.  Seems like that should be factored out into a common finishing function.
+  =org-agenda-run-series= might be the way to do this, or at least a model to follow.  This may be how custom commands are dispatched...

[2017-07-23 Sun 14:27] This is basically copying =org-agenda-list=...this may get messy, but I don't think there's an alternative, because I have to make separate sections.

On the other hand, maybe I should look at the custom commands...that might end up being a lot less work...

[2017-07-23 Sun 14:34] It looks like I basically do have to make my own command from scratch.  =org-agenda-run-series= calls commands like =org-agenda-list=, so I have to do what =org-agenda-list=, =org-tags-view=, etc. do.  See the =cond= in =org-agenda=.  I think what I can do is, make my command one that =org-agenda= calls...maybe.  So maybe I should just copy =org-agenda-list= and then modify it.  I hate to do this, in a way, because it will get out-of-sync if/when Org changes that function.  But I don't see any alternative for now.

#+BEGIN_SRC elisp
  (let ((org-agenda-buffer-name "super-agenda")
        (agenda-items (seq-subseq (org-agenda-get-day-entries "~/org/main.org"
                                                              (calendar-current-date)
                                                              :deadline)
                                  0 5)))
    (org-agenda-prepare "super agenda")
    (org-set-sorting-strategy 'agenda)
    (insert (org-agenda-finalize-entries agenda-items 'agenda)
            "\n"))
#+END_SRC

*** TODO Copy and modify =org-agenda-list=

#+BEGIN_SRC elisp
  (cl-defun org-super-agenda (&optional arg start-day span with-hour)
    "SUPER-FILTERS should be a list like (FILTER-FN ARG), e.g.:

    '(osa/separate-by-any-tags (\"bills\"))"
    (interactive "P")
    (if org-agenda-overriding-arguments
        (setq arg (car org-agenda-overriding-arguments)
              start-day (nth 1 org-agenda-overriding-arguments)
              span (nth 2 org-agenda-overriding-arguments)))
    (if (and (integerp arg) (> arg 0))
        (setq span arg arg nil))
    (catch 'exit
      (setq org-agenda-buffer-name
            (or org-agenda-buffer-tmp-name
                (if org-agenda-sticky
                    (cond ((and org-keys (stringp org-match))
                           (format "*Org Agenda(%s:%s)*" org-keys org-match))
                          (org-keys
                           (format "*Org Agenda(%s)*" org-keys))
                          (t "*Org Agenda(a)*")))
                org-agenda-buffer-name))
      (org-agenda-prepare "Day/Week")
      (setq start-day (or start-day org-agenda-start-day))
      (if (stringp start-day)
          ;; Convert to an absolute day number
          (setq start-day (time-to-days (org-read-date nil t start-day))))
      (org-compile-prefix-format 'agenda)
      (org-set-sorting-strategy 'agenda)
      (let* ((span (org-agenda-ndays-to-span (or span org-agenda-span)))
             (today (org-today))
             (sd (or start-day today))
             (ndays (org-agenda-span-to-ndays span sd))
             (org-agenda-start-on-weekday
              (if (or (eq ndays 7) (eq ndays 14))
                  org-agenda-start-on-weekday))
             (thefiles (org-agenda-files nil 'ifmode))
             (files thefiles)
             (start (if (or (null org-agenda-start-on-weekday)
                            (< ndays 7))
                        sd
                      (let* ((nt (calendar-day-of-week
                                  (calendar-gregorian-from-absolute sd)))
                             (n1 org-agenda-start-on-weekday)
                             (d (- nt n1)))
                        (- sd (+ (if (< d 0) 7 0) d)))))
             (day-numbers (list start))
             (day-cnt 0)
             (inhibit-redisplay (not debug-on-error))
             (org-agenda-show-log-scoped org-agenda-show-log)
             s e rtn rtnall file date d start-pos end-pos todayp
             clocktable-start clocktable-end filter)
        (setq org-agenda-redo-command
              (list 'org-agenda-list (list 'quote arg) start-day (list 'quote span) with-hour))
        (dotimes (n (1- ndays))
          (push (1+ (car day-numbers)) day-numbers))
        (setq day-numbers (nreverse day-numbers))
        (setq clocktable-start (car day-numbers)
              clocktable-end (1+ (or (org-last day-numbers) 0)))
        (setq-local org-starting-day (car day-numbers))
        (setq-local org-arg-loc arg)
        (setq-local org-agenda-current-span (org-agenda-ndays-to-span span))
        (unless org-agenda-compact-blocks
          (let* ((d1 (car day-numbers))
                 (d2 (org-last day-numbers))
                 (w1 (org-days-to-iso-week d1))
                 (w2 (org-days-to-iso-week d2)))
            (setq s (point))
            (if org-agenda-overriding-header
                (insert (org-add-props (copy-sequence org-agenda-overriding-header)
                            nil 'face 'org-agenda-structure) "\n")
              (insert (org-agenda-span-name span)
                      "-agenda"
                      (if (< (- d2 d1) 350)
                          (if (= w1 w2)
                              (format " (W%02d)" w1)
                            (format " (W%02d-W%02d)" w1 w2))
                        "")
                      ":\n")))
          (add-text-properties s (1- (point)) (list 'face 'org-agenda-structure
                                                    'org-date-line t))
          (org-agenda-mark-header-line s))
        (while (setq d (pop day-numbers))
          (setq date (calendar-gregorian-from-absolute d)
                s (point))
          (if (or (setq todayp (= d today))
                  (and (not start-pos) (= d sd)))
              (setq start-pos (point))
            (if (and start-pos (not end-pos))
                (setq end-pos (point))))
          (setq files thefiles
                rtnall nil)
          (while (setq file (pop files))
            (catch 'nextfile
              (org-check-agenda-file file)
              (let ((org-agenda-entry-types org-agenda-entry-types))
                ;; Starred types override non-starred equivalents
                (when (member :deadline* org-agenda-entry-types)
                  (setq org-agenda-entry-types
                        (delq :deadline org-agenda-entry-types)))
                (when (member :scheduled* org-agenda-entry-types)
                  (setq org-agenda-entry-types
                        (delq :scheduled org-agenda-entry-types)))
                ;; Honor with-hour
                (when with-hour
                  (when (member :deadline org-agenda-entry-types)
                    (setq org-agenda-entry-types
                          (delq :deadline org-agenda-entry-types))
                    (push :deadline* org-agenda-entry-types))
                  (when (member :scheduled org-agenda-entry-types)
                    (setq org-agenda-entry-types
                          (delq :scheduled org-agenda-entry-types))
                    (push :scheduled* org-agenda-entry-types)))
                (unless org-agenda-include-deadlines
                  (setq org-agenda-entry-types
                        (delq :deadline* (delq :deadline org-agenda-entry-types))))
                (cond
                 ((memq org-agenda-show-log-scoped '(only clockcheck))
                  (setq rtn (org-agenda-get-day-entries
                             file date :closed)))
                 (org-agenda-show-log-scoped
                  (setq rtn (apply 'org-agenda-get-day-entries
                                   file date
                                   (append '(:closed) org-agenda-entry-types))))
                 (t
                  (setq rtn (apply 'org-agenda-get-day-entries
                                   file date
                                   org-agenda-entry-types)))))
              (setq rtnall (append rtnall rtn)))) ;; all entries

          (if org-agenda-include-diary
              ;; Diary
              (let ((org-agenda-search-headline-for-time t))
                (require 'diary-lib)
                (setq rtn (org-get-entries-from-diary date))
                (setq rtnall (append rtnall rtn))))

          (if (or rtnall org-agenda-show-all-dates)
              ;; Insert results
              (progn
                (setq day-cnt (1+ day-cnt))
                (insert
                 (if (stringp org-agenda-format-date)
                     (format-time-string org-agenda-format-date
                                         (org-time-from-absolute date))
                   (funcall org-agenda-format-date date))
                 "\n")
                (put-text-property s (1- (point)) 'face
                                   (org-agenda-get-day-face date))
                (put-text-property s (1- (point)) 'org-date-line t)
                (put-text-property s (1- (point)) 'org-agenda-date-header t)
                (put-text-property s (1- (point)) 'org-day-cnt day-cnt)
                (when todayp
                  (put-text-property s (1- (point)) 'org-today t))
                (setq rtnall
                      (org-agenda-add-time-grid-maybe rtnall ndays todayp))

                ;; Actually insert results
                (when rtnall
                  ;; Insert each filtered sublist
                  (cl-loop with filter-fn
                           with args
                           for filter in super-filters
                           if (functionp filter) do (setq filter-fn filter
                                                          args nil)
                           else do (progn
                                     (setq filter-fn (car filter)
                                           args (cadr filter)))
                           for (section-name non-matching matching) = (funcall filter-fn rtnall args)
                           collect (cons section-name matching) into sections
                           and do (setq rtnall non-matching)
                           finally do (progn
                                        ;; Insert sections
                                        (cl-loop for (section-name . items) in sections
                                                 when items
                                                 do (progn
                                                      (osa/insert-agenda-header section-name)
                                                      (insert (org-agenda-finalize-entries items 'agenda)
                                                              "\n\n")))

                                        (when non-matching
                                          ;; Insert non-matching items in main section
                                          (osa/insert-agenda-header "Other items")
                                          (insert (org-agenda-finalize-entries non-matching 'agenda)
                                                  "\n")))))


                (put-text-property s (1- (point)) 'day d)
                (put-text-property s (1- (point)) 'org-day-cnt day-cnt))))

        (when (and org-agenda-clockreport-mode clocktable-start)
          ;; Clocktable
          (let ((org-agenda-files (org-agenda-files nil 'ifmode))
                ;; the above line is to ensure the restricted range!
                (p (copy-sequence org-agenda-clockreport-parameter-plist))
                tbl)
            (setq p (org-plist-delete p :block))
            (setq p (plist-put p :tstart clocktable-start))
            (setq p (plist-put p :tend clocktable-end))
            (setq p (plist-put p :scope 'agenda))
            (setq tbl (apply 'org-clock-get-clocktable p))
            (insert tbl)))

        ;; Window stuff
        (goto-char (point-min))
        (or org-agenda-multi (org-agenda-fit-window-to-buffer))
        (unless (and (pos-visible-in-window-p (point-min))
                     (pos-visible-in-window-p (point-max)))
          (goto-char (1- (point-max)))
          (recenter -1)
          (if (not (pos-visible-in-window-p (or start-pos 1)))
              (progn
                (goto-char (or start-pos 1))
                (recenter 1))))
        (goto-char (or start-pos 1))

        ;; Add text properties to entire buffer
        (add-text-properties (point-min) (point-max)
                             `(org-agenda-type agenda
                                               org-last-args (,arg ,start-day ,span)
                                               org-redo-cmd ,org-agenda-redo-command
                                               org-series-cmd ,org-cmd))

        (if (eq org-agenda-show-log-scoped 'clockcheck)
            (org-agenda-show-clocking-issues))

        (org-agenda-finalize)
        (setq buffer-read-only t)
        (message ""))))

  (defun osa/insert-agenda-header (s)
    "Insert agenda header into current buffer containing string S and a newline."
    (insert (org-add-props s nil 'face 'org-agenda-structure) "\n"))

    (org-super-agenda nil nil 'day nil :super-filters '((osa/separate-by-any-tags ("bills" "apartment"))))
#+END_SRC
