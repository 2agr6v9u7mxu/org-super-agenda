* Test data

Rather than using my personal agenda every time I want to take a screenshot, how about this.

Will try to open the agenda view as if it was [2017-07-05 Wed]

** TODO [#A] Take over the world                                     :world:
DEADLINE: <2017-07-07 Fri>

I'd like to be finished with this before the weekend...

** TODO [#A] Skype with president of Antarctica             :world:meetings:
SCHEDULED: <2017-07-05 Wed 21:00>

Not sure what his timezone is...

** TODO Order a pizza                                          :food:dinner:
SCHEDULED: <2017-07-05 Wed 18:00>

** SOMEDAY Rewrite Emacs in Common Lisp :Emacs:elisp:computers:software:programming:
SCHEDULED: <2017-07-05 Wed>
:LOGBOOK:
-  State "SOMEDAY"    from "MAYBE"      [2017-07-24 Mon 18:59]
-  State "MAYBE"      from              [2017-07-24 Mon 18:58]
:END:

I mean, since no one has ever tried doing it before...

** CHECK /r/emacs                                            :website:Emacs:
DEADLINE: <2017-07-05 Wed>
:LOGBOOK:
-  State "CHECK"      from              [2017-07-24 Mon 19:00]
:END:

** WAITING Visit the moon <2017-08-27 Sun -2m>                                    :space:travel: 
:LOGBOOK:
-  State "WAITING"    from              [2017-07-24 Mon 19:01]
:END:

Just waiting on that callback from NASA...

** TODO Visit Mars                                            :space:travel:planet:
SCHEDULED: <2017-09-20 Wed -3m>

Ah, the red planet...

** TODAY [#C] Get haircut                                   :personal:@town:
SCHEDULED: <2017-07-05 Wed>

Should probably do this before I take over the world.  Want to look my best.  (Not that it will matter once I'm in charge.)

** TODO [#B] Internet                                                :bills:
DEADLINE: <2017-07-21 Fri -1m>

** TODO [#A] Spaceship lease                               :bills:spaceship:
DEADLINE: <2017-08-01 Tue -1m>

** TODO [#B] Fix flux capacitor               :spaceship:shopping:@computer:
SCHEDULED: <2017-07-06 Thu -1w>

If I don't, the frobnicator will probably fall off halfway to Mars...

Gotta buy one first, though.

** TODO Practice leaping tall buildings in a single bound         :personal:
SCHEDULED: <2017-07-05 Wed +2d>
:PROPERTIES:
:STYLE:    habit
:END:

** TODO [#B] Renew membership in supervillain club
DEADLINE: <2017-07-10 Mon -1w>

** TODO Shop for groceries                             :food:shopping:@town:
SCHEDULED: <2017-07-05 Wed>

* Code

#+BEGIN_SRC elisp :results none
  ;; Setup code
  (require 'org-super-agenda)
  (org-super-agenda-mode 1)
  (require 'org-habit)
  (setq org-todo-keywords
        '((sequence "TODO(t!)" "TODAY(a!)" "NEXT(n!)" "STARTED(s!)" "IN-PROGRESS(p!)" "UNDERWAY(u!)" "WAITING(w@)" "SOMEDAY(o!)" "MAYBE(m!)" "|" "DONE(d@)" "CANCELED(c@)")
          (sequence "CHECK(k!)" "|" "DONE(d@)")
          (sequence "TO-READ(r!)" "READING(R!)" "|" "HAVE-READ(d@)")
          (sequence "TO-WATCH(!)" "WATCHING(!)" "SEEN(!)")))
  (with-current-buffer "test.org" (revert-buffer))
#+END_SRC

#+BEGIN_SRC elisp
  (defmacro with-org-today-date (date &rest body)
    "Run BODY with the `org-today' function set to return simply DATE.
  DATE should be a date-time string (both date and time must be included)."
    (declare (indent defun))
    `(let ((day (date-to-day ,date))
           (orig (symbol-function 'org-today)))
       (unwind-protect
           (progn
             (fset 'org-today (lambda () day))
             ,@body)
         (fset 'org-today orig))))
#+END_SRC

#+BEGIN_SRC elisp
  (with-org-today-date "2017-07-05 00:00"
    (let ((org-agenda-files (list "~/src/org-super-agenda/test.org"))
          (org-agenda-span 'day))
      (org-agenda-list nil "2017-07-05")))

  (with-org-today-date "2017-07-05 00:00"
    (let ((org-agenda-files (list "~/src/org-super-agenda/test.org"))
          (org-agenda-span 'day)
          (org-super-agenda-groups
           '(;; Each group has an implicit boolean OR operator between its selectors.
             (:name "Today" ; Optionally specify section name
                    :time t ; Items that have a time associated
                    :todo "TODAY") ; Items that have this TODO keyword
             (:name "Important"
                    ;; Single arguments given alone
                    :tag "bills"
                    :priority "A")
             ;; Set order of multiple groups at once
             (:order-multi (2 (:name "Shopping in town"
                                     ;; Boolean AND group matches items that match all subgroups
                                     :and (:tag "shopping" :tag "@town"))
                              (:name "Food-related"
                                     ;; Multiple args given in list with implicit OR
                                     :tag ("food" "dinner"))
                              (:name "Personal"
                                     :habit t
                                     :tag "personal")
                              (:name "Space-related (non-moon-or-planet-related)"
                                     ;; Regexps match case-insensitively on the entire entry
                                     :and (:regexp ("space" "NASA")
                                                   ;; Boolean NOT also has implicit OR between selectors
                                                   :not (:regexp "moon" :tag "planet")))))
             ;; Groups supply their own section names when none are given
             (:todo "WAITING" :order 8) ; Set order of this section
             (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
                    ;; Show this group at the end of the agenda (since it has the
                    ;; highest number). If you specified this group last, items
                    ;; with these todo keywords that e.g. have priority A would be
                    ;; displayed in that group instead, because items are grouped
                    ;; out in the order the groups are listed.
                    :order 9)
             (:priority ("B" "C")
                        ;; Show this section after "Today" and "Important", because
                        ;; their order is unspecified, defaulting to 0. Sections
                        ;; are displayed lowest-number-first.
                        :order 1)
             ;; After the last group, the agenda will display items that didn't
             ;; match any of these groups, with the default order position of 99
             )))
      (org-agenda nil "a")))

  (with-org-today-date "2017-07-05 00:00"
    (let ((org-agenda-files (list "~/src/org-super-agenda/test.org"))
          (org-agenda-span 'day)
          (org-super-agenda-groups
           '((:discard (:regexp "pizza"
                                :regexp "groceries")))))
      (org-agenda nil "a")))


#+END_SRC

#+BEGIN_SRC elisp
    ;; Before
  (let ((org-agenda-files (list "~/src/org-super-agenda/test2.org"))
;;	(org-agenda-start-day "2017-07-")  ; So I don't have to keep adjusting the dates forward
	(org-agenda-span 'day)
)
    (org-agenda-list nil "2017-07-05"))

(let ((org-agenda-files (list "~/src/org-super-agenda/test2.org"))
;;	(org-agenda-start-day "2017-07-")  ; So I don't have to keep adjusting the dates forward
	(org-agenda-span 'day))
(cl-flet ((org-today nil 736515))
    (org-agenda-list nil "2017-07-05")))

(let ((org-agenda-files (list "~/src/org-super-agenda/test2.org"))
;;	(org-agenda-start-day "2017-07-")  ; So I don't have to keep adjusting the dates forward
	(org-agenda-span 'day))
(cl-labels ((org-today nil 736515))
    (org-agenda-list nil )))

(let ((org-agenda-files (list "~/src/org-super-agenda/test2.org"))
;;	(org-agenda-start-day "2017-07-")  ; So I don't have to keep adjusting the dates forward
	(org-agenda-span 'day))
(cl-labels ((org-today nil 736515))
    (org-today )))

(defun org-today ()
  "Return today date, considering `org-extend-today-until'."
  (time-to-days
   (time-subtract (current-time)
		  (list 0 (* 3600 org-extend-today-until) 0))))

(defun org-today ()
  "Return today date, considering `org-extend-today-until'."
  736515)

;; 736515

    ;; After
    (let ((org-agenda-files (list "~/src/org-super-agenda/test2.org"))
	  (org-agenda-custom-commands
	   '(("u" "SUPER Agenda"
	      org-super-agenda ""
	      ((org-agenda-span 'day)
	       (org-agenda-start-day "2017-07-28")  ; So I don't have to keep adjusting the dates forward
	       (org-super-agenda-groups
		'(;; Each group has an implicit boolean OR operator between its selectors.
		  (:name "Today"  ; Optionally specify section name
			 :time t  ; Items that have a time associated
			 :todo "TODAY")  ; Items that have this TODO keyword
		  (:name "Important"
			 ;; Single arguments given alone
			 :tag "bills"
			 :priority "A")
		  ;; Set order of multiple groups at once
		  (:order-multi (2 (:name "Shopping in town"
					  ;; Boolean AND group matches items that match all subgroups
					  :and (:tag "shopping" :tag "@town"))
				   (:name "Food-related"
					  ;; Multiple args given in list with implicit OR
					  :tag ("food" "dinner"))
				   (:name "Personal"
					  :habit t
					  :tag "personal")
				   (:name "Space-related (non-moon-or-planet-related)"
					  ;; Regexps match case-insensitively on the entire entry
					  :and (:regexp ("space" "NASA")
							;; Boolean NOT also has implicit OR between selectors
							:not (:regexp "moon" :tag "planet")))))
		  ;; Groups supply their own section names when none are given
		  (:todo "WAITING" :order 8)  ; Set order of this section
		  (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
			 ;; Show this group at the end of the agenda (since it has the
			 ;; highest number). If you specified this group last, items
			 ;; with these todo keywords that e.g. have priority A would be
			 ;; displayed in that group instead, because items are grouped
			 ;; out in the order the groups are listed.
			 :order 9)
		  (:priority ("B" "C")
			     ;; Show this section after "Today" and "Important", because
			     ;; their order is unspecified, defaulting to 0.  Sections
			     ;; are displayed lowest-number-first.
			     :order 1)
		  ;; After the last group, the agenda will display items that didn't
		  ;; match any of these groups, with the default order position of 99
		  )))))))
      (org-agenda nil "u"))

    (let ((org-agenda-files (list "~/src/org-super-agenda/test.org"))
	  (org-agenda-span 'day)
	  (org-super-agenda-groups
	   '(;; Each group has an implicit boolean OR operator between its selectors.
	     (:name "Today"  ; Optionally specify section name
		    :time t  ; Items that have a time associated
		    :todo "TODAY")  ; Items that have this TODO keyword
	     (:name "Important"
		    ;; Single arguments given alone
		    :tag "bills"
		    :priority "A")
	     ;; Set order of multiple groups at once
	     (:order-multi (2 (:name "Shopping in town"
				     ;; Boolean AND group matches items that match all subgroups
				     :and (:tag "shopping" :tag "@town"))
			      (:name "Food-related"
				     ;; Multiple args given in list with implicit OR
				     :tag ("food" "dinner"))
			      (:name "Personal"
				     :habit t
				     :tag "personal")
			      (:name "Space-related (non-moon-or-planet-related)"
				     ;; Regexps match case-insensitively on the entire entry
				     :and (:regexp ("space" "NASA")
						   ;; Boolean NOT also has implicit OR between selectors
						   :not (:regexp "moon" :tag "planet")))))
	     ;; Groups supply their own section names when none are given
	     (:todo "WAITING" :order 8)  ; Set order of this section
	     (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
		    ;; Show this group at the end of the agenda (since it has the
		    ;; highest number). If you specified this group last, items
		    ;; with these todo keywords that e.g. have priority A would be
		    ;; displayed in that group instead, because items are grouped
		    ;; out in the order the groups are listed.
		    :order 9)
	     (:priority ("B" "C")
			;; Show this section after "Today" and "Important", because
			;; their order is unspecified, defaulting to 0.  Sections
			;; are displayed lowest-number-first.
			:order 1)
	     ;; After the last group, the agenda will display items that didn't
	     ;; match any of these groups, with the default order position of 99
	     )))
      (org-agenda nil "a"))

    (let ( (org-super-agenda-groups
	    '((:todo "WAITING"))))
      (org-todo-list))

  (let ( (org-super-agenda-groups
	    '((:todo "WAITING"))))
      (org-tags-view nil "Emacs"))

  (let ( (org-super-agenda-groups
	    '((:todo "WAITING"))))
      (org-search-view nil "Emacs"))

  (let ( (org-super-agenda-groups
	    '((:regexp "moon")))
  (org-agenda-files (list "~/src/org-super-agenda/test.org")))
      (org-search-view nil "space"))

  (let ( (org-super-agenda-groups
	    '((:todo "SOMEDAY")))
  (org-agenda-files (list "~/src/org-super-agenda/test.org")))
      (org-agenda-list nil nil 'day))




    (let ((org-agenda-files (list "~/src/org-super-agenda/test.org"))
	  (org-agenda-custom-commands
	   '(("u" "SUPER Agenda"
	      org-super-agenda ""
	      ((org-agenda-span 'day)
	       (org-super-agenda-groups
		'((:discard (:not (:tag ("Emacs" "bills") :regexp "space"))))))))))
      (org-agenda nil "u"))
#+END_SRC

** Misc

*** let-plist

I don't need this right now, but it might come in handy here or elsewhere.

#+BEGIN_SRC elisp
  (defmacro osa/let-plist (keys plist &rest body)
    "`cl-destructuring-bind' without the boilerplate for plists."
    ;; See https://emacs.stackexchange.com/q/22542/3871

    ;; I really don't understand why Emacs doesn't have this already.
    ;; So many things come close to it: pcase, pcase-let, map-let,
    ;; cl-destructuring-bind, -let...but none of them let you simply
    ;; bind all the values of a plist to variables with the same name as
    ;; their keys. You always have to type the name of the key twice.

    ;; For example, compare these two forms:

    ;; (-let (((&keys :from from :to to :date date :subject subject) email))
    ;;   (list from to date subject))

    ;; (osa/let-plist (:from :to :date :subject) email
    ;;   (list from to date subject))

    ;; Now, sure, sometimes you need to bind values to differently named
    ;; variables. But when you don't, I know which one I prefer.
    (declare (indent defun))
    (setq keys (cl-loop for key in keys
                        collect (intern (replace-regexp-in-string (rx bol ":") ""
                                                                  (symbol-name key)))))
    `(cl-destructuring-bind
         (&key ,@keys &allow-other-keys)
         ,plist
       ,@body))
#+END_SRC
