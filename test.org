* Test data

Rather than using my personal agenda every time I want to take a screenshot, how about this.

** TODAY [#A] Take over the world                                    :world:
DEADLINE: <2017-07-28 Fri -1m>

I'd like to be finished with this before the weekend...

** TODO [#A] Skype with president of Antarctica             :world:meetings:
SCHEDULED: <2017-07-26 Wed 21:00>

Not sure what his timezone is...

** TODO Order a pizza                                          :food:dinner:
SCHEDULED: <2017-07-26 Wed 18:00>

** SOMEDAY Rewrite Emacs in Common Lisp :Emacs:elisp:computers:software:programming:
DEADLINE: <2017-07-26 Wed>
:LOGBOOK:
-  State "SOMEDAY"    from "MAYBE"      [2017-07-24 Mon 18:59]
-  State "MAYBE"      from              [2017-07-24 Mon 18:58]
:END:

I mean, since no one has ever tried doing it before...

** CHECK /r/emacs                                            :website:Emacs:
DEADLINE: <2017-08-25 Fri -2m>
:LOGBOOK:
-  State "CHECK"      from              [2017-07-24 Mon 19:00]
:END:

** WAITING Visit the moon                                     :space:travel:
SCHEDULED: <2017-06-27 Tue>
:LOGBOOK:
-  State "WAITING"    from              [2017-07-24 Mon 19:01]
:END:

Just waiting on that callback from NASA...

** TODO [#C] Get haircut                                    :personal:@town:
SCHEDULED: <2017-07-26 Wed>

Should probably do this before I take over the world.  Want to look my best.  (Not that it will matter once I'm in charge.)

** TODO [#B] Internet                                                :bills:
DEADLINE: <2017-08-21 Mon -1m>

** TODO [#A] Spaceship lease                               :bills:spaceship:
DEADLINE: <2017-07-26 Wed +1m>

** TODO [#A] Fix flux capacitor                                  :spaceship:
SCHEDULED: <2017-07-22 Sat>

If I don't, the frobnicator will probably fall off halfway to Mars...

** TODO Practice leaping tall buildings in a single bound         :personal:
SCHEDULED: <2017-07-24 Mon +2d>
:PROPERTIES:
:STYLE:    habit
:END:

** TODO [#B] Renew membership in supervillain club
DEADLINE: <2017-07-24 Mon>

** TODO Shop for groceries                                            :food:
SCHEDULED: <2017-07-17 Mon>

* Code

#+BEGIN_SRC elisp
  ;; Before
  (let ((org-agenda-files (list "~/src/org-super-agenda/test.org"))
        (org-agenda-custom-commands
         (list '("u" "SUPER Agenda"
                 org-super-agenda ""
                 ((org-agenda-span 'day))))))
    (org-agenda nil "u"))

  ;; After
  (let ((org-agenda-files (list "~/src/org-super-agenda/test.org"))
        (org-agenda-custom-commands
         '(("u" "SUPER Agenda"
            org-super-agenda ""
            ((org-agenda-span 'day)
             (org-super-agenda-groups
              '(;; Each group has an implicit boolean OR operator between its selectors.
                (:name "Today"  ; Optionally specify section name
                       :time t  ; Items that have a time associated
                       :todo "TODAY")  ; Items that have this TODO keyword
                (:name "Important"
                       ;; Single arguments given alone
                       :any-tags "bills"
                       :priority "A")
                (:name "Food-related"
                       ;; Multiple args given in list
                       :any-tags ("food" "dinner"))
                (:name "Personal"
                       :habit t
                       :any-tags "personal")
                ;; Filter functions supply their own section names when none are given
                (:todo "WAITING")
                (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
                       ;; Show this section at the end of the agenda. If you specified
                       ;; this filter last, items with these todo keywords that have
                       ;; priority A, B, or C would be displayed in those sections
                       ;; instead, because items are filtered out in the order the
                       ;; filters are listed.
                       :last t)
                (:priority ("B" "C")))))))))
    (org-agenda nil "u"))
#+END_SRC

** More declarative

#+BEGIN_SRC elisp
  (let ((org-agenda-files (list "~/src/org-super-agenda/test.org"))
        (org-agenda-custom-commands
         '(("u" "SUPER Agenda"
            org-super-agenda ""
            ((org-agenda-span 'day)
             (org-agenda-groups '((:name "Today"
                                         :or (:time t :todo "TODAY"))
                                  (:name "Important"
                                         :or (:any-tags "bills" :priority "A"))
                                  (:name "Food-related"
                                         :any-tags ("food" "dinner"))
                                  (:name "Personal"
                                         :or (:habit t :any-tags "personal"))
                                  (:todo "WAITING")
                                  (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
                                         :last t)
                                  (:priority ("B" "C")))))))))
    (org-agenda nil "u"))

    ;; (defun osa/dispatch-group (group items)
    ;;   (osa/let-plist (:name :or :habit :priority :time :todo :tags) group
    ;;     (let  ((fn (cond
    ;;                 ((and or) (osa/filter-or items or))
    ;;                 (habit (osa/filter-habit items habit))
    ;;                 (priority (osa/filter-priority items priority))
    ;;                 (time (osa/filter-time items time))
    ;;                 (todo (osa/filter-todo-keyword items todo))
    ;;                 (tags (osa/filter-any-tag items tags))))))))

    (defun osa/dispatch-group (group items)
      (let ((org-super-agenda-group-types '(:or :habit :priority :time :todo :tags)))
        (cl-loop with fn
                 for group-type in org-super-agenda-group-types
                 for args = (plist-get group group-type)
                 when args
                 do (setq fn (intern (concat "osa/filter-"
                                             (replace-regexp-in-string (rx bol ":") ""
                                                                       (symbol-name group-type)))))
                 and return (list fn items args))))

    (defmacro osa/let-plist (keys plist &rest body)
      "`cl-destructuring-bind' without the boilerplate for plists."
      ;; See https://emacs.stackexchange.com/q/22542/3871

      ;; I really don't understand why Emacs doesn't have this already.
      ;; So many things come close to it: pcase, pcase-let, map-let,
      ;; cl-destructuring-bind, -let...but none of them let you simply
      ;; bind all the values of a plist to variables with the same name as
      ;; their keys.  You always have to type the name of the key twice.

      ;; For example, compare these two forms:

      ;; (-let (((&keys :from from :to to :date date :subject subject) email))
      ;;   (list from to date subject))

      ;; (osa/let-plist (:from :to :date :subject) email
      ;;   (list from to date subject))

      ;; Now, sure, sometimes you need to bind values to differently named
      ;; variables.  But when you don't, I know which one I prefer.
      (declare (indent defun))
      (setq keys (cl-loop for key in keys
                          collect (intern (replace-regexp-in-string (rx bol ":") ""
                                                                    (symbol-name key)))))
      `(cl-destructuring-bind
           (&key ,@keys &allow-other-keys)
           ,plist
         ,@body))

    (let* ((groups '((:name "Today" :or (:time t :todo "TODAY"))
                     (:name "Important" :or (:tags "bills" :priority "A"))
                     (:name "Food-related" :tags ("food" "dinner"))
                     (:name "Personal" :or (:habit t :tags "personal"))
                     (:todo "WAITING")
                     (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING") :last t)
                     (:priority ("B" "C"))))
           (items '(1 2 3)))
      (cl-loop for group in groups
               collect (osa/dispatch-group group items)))


    (defun osa/insert-sections (all-items)
      "Divide ALL-ITEMS into sections and insert them into the agenda."
      ;; This essentially replaces the part of `org-agenda-list' that
      ;; finally inserts the `rtnall' variable.
      (if (bound-and-true-p org-agenda-super-filters)
          (cl-loop with filter-fn
                   with args
                   with last
                   for filter in org-agenda-groups
                   for custom-section-name = (plist-get filter :name)
                   for last = (plist-get filter :last)
                   for (auto-section-name non-matching matching) = (osa/dispatch-group filter)
                   for section-name = (or custom-section-name auto-section-name)

                   ;; FIXME: This repetition is kind of ugly, but I guess cl-loop is worth it...
                   if last collect (cons section-name matching) into last-sections
                   and do (setq all-items non-matching)
                   else collect (cons section-name matching) into sections
                   and do (setq all-items non-matching)

                   finally do
                   (progn
                     ;; Insert sections
                     (cl-loop for (section-name . items) in sections
                              when items
                              do (progn
                                   (osa/insert-agenda-header section-name)
                                   (insert (org-agenda-finalize-entries items 'agenda)
                                           "\n\n")))
                     (when non-matching
                       ;; Insert non-matching items in main section
                       (osa/insert-agenda-header "Other items")
                       (insert (org-agenda-finalize-entries non-matching 'agenda)
                               "\n\n"))

                     ;; Insert final sections
                     (cl-loop for (section-name . items) in last-sections
                              when items
                              do (progn
                                   (osa/insert-agenda-header section-name)
                                   (insert (org-agenda-finalize-entries items 'agenda)
                                           "\n\n")))))
        ;; No super-filters; insert normally
        (insert (org-agenda-finalize-entries all-items 'agenda)
                "\n")))
#+END_SRC

*** Implicit or

#+BEGIN_SRC elisp
  (let ((org-agenda-files (list "~/src/org-super-agenda/test.org"))
        (org-agenda-custom-commands
         '(("u" "SUPER Agenda"
            org-super-agenda ""
            ((org-agenda-span 'day)
             (org-agenda-groups '(;; Each group has an implicit boolean OR operator between its selectors.
                                  (:name "Today"  ; Optionally specify section name
                                         :time t  ; Items that have a time associated
                                         :todo "TODAY")  ; Items that have this TODO keyword
                                  (:name "Important"
                                         ;; Single arguments given alone
                                         :any-tags "bills"
                                         :priority "A")
                                  (:name "Food-related"
                                         ;; Multiple args given in list
                                         :any-tags ("food" "dinner"))
                                  (:name "Personal"
                                         :habit t
                                         :any-tags "personal")
                                  ;; Filter functions supply their own section names when none are given
                                  (:todo "WAITING")
                                  (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
                                         ;; Show this section at the end of the agenda. If you specified
                                         ;; this filter last, items with these todo keywords that have
                                         ;; priority A, B, or C would be displayed in those sections
                                         ;; instead, because items are filtered out in the order the
                                         ;; filters are listed.
                                         :last t)
                                  (:priority ("B" "C")))))))))
    (org-agenda nil "u"))
#+END_SRC
